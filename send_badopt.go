package main

import (
	"fmt"
	"net"

	"golang.org/x/net/ipv4"

	"github.com/unixpickle/essentials"
	"github.com/unixpickle/learnet/ipstack"
)

const PayloadSize = 128

func main() {
	sourceStr := "192.168.1.147"
	destStr := "192.168.1.121"
	source, err := net.ResolveIPAddr("ip", sourceStr)
	essentials.Must(err)
	dest, err := net.ResolveIPAddr("ip", destStr)
	essentials.Must(err)
	conn, err := net.ListenIP("ip4:icmp", source)
	essentials.Must(err)
	rawConn, err := ipv4.NewRawConn(conn)
	essentials.Must(err)
	payload := makePayload()
	header := makeHeader(dest.IP, makeOptions(), payload)
	fmt.Println(header)
	essentials.Must(err)
	if err := rawConn.WriteTo(header, makePayload(), nil); err != nil {
		fmt.Println(err)
	}
}

func makeHeader(dest net.IP, options, payload []byte) *ipv4.Header {
	return &ipv4.Header{
		Version:  4,
		Len:      20 + len(options),
		TOS:      0,
		TotalLen: 20 + len(options) + len(payload),
		TTL:      64,
		Protocol: ipstack.ProtocolNumberICMP,
		Dst:      dest,
		Options:  options,
	}
}

func makeOptions() []byte {
	//return nil
	return []byte{0x44, 2, 0, 0}
}

func makePayload() []byte {
	res := make(ipstack.ICMPPacket, 8+PayloadSize)
	res.SetType(ipstack.ICMPTypeEchoRequest)
	res.SetChecksum()
	return res
}
